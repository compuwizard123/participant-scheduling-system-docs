\section{GRASP Principles}
\subsection{Creator}
In our system, there are many objects which must be created.  One notable example of this is the creation of participation slots.  A date-time range, the time period over which the experiment is being run, can create for itself several slots, or chunks within the time period, which participants can sign up for.  Since these slots only pertain to one date-time range, the range is the one to create and manage them.

\subsection{Info Expert}
For information expert, an example from our system would be the Experiment class.  An Experiment has knowledge of ExperimentDate, ExperimentDateTimeRange, Slots, Appointments, Participants, Room, Researchers, and everything else pertaining to an instance of an experiment.  When something needs to be done by or to an experiment, that experiment will have all of the necessary information, so it can be relied on to complete those tasks.

\subsection{Controller}
One nice example of a controller in our system is the URLs.  Each URL can be broken up so the system will know what should handle the user's input.  For example, in the case of experiments/dates/edit/[an experiment id], the system would turn to the experiment editing code.  Each URL our system uses works this way, meaning that all the power of what is displayed on each page is delegated exclusively by the URL handling.

\subsection{High Cohesion}
High cohesion is achieved in many parts of our code, but an example of where cohesion is extremely strong is in the Administration code.  All of our Administration  procedures, fields, responsibilities, and all similar objects are located in the administration package, specifically in the django.contrib.admin package as seen in the package diagram in section 4 of this document.  By having administration as its own package, it leaves other administration tasks out of other unrelated classes in our system.

\subsection{Low Coupling}
By separating out objects and responsibilities into our their own packages, we achieve a fairly low coupling.  Each separate package contains a responsibility and is connected only to the classes to which must be connected.  Our class diagram in section 5, shows how our classes interact with each other and also shows that each class is used only by a class that needs its information.  For example, Qualification is only connected to Experiment; if could possibly be connected to participant, but because you will not be able to completely verify the participants qualifications until they show up for the experiment, there is no need to make the connection between Participant and Qualifications.

\subsection{Pure Fabrication}
Pure Fabrication becomes uses in our system by creating ExperimentDateTimeRange and ExperimentDate.  Neither of these two classes are in the domain model, but since they make the code easier to work with and separate out responsibility, increasing cohesion, they become very useful as classes.  Should we not have these two classes Slot or Experiment would have to contain this information, which would decrease cohesion and generally add to the complexity of the Slot or Experiment or both.

\subsection{Indirection}
The GRASP principle indirection directly relates to our system for how we need to represent experiment dates and the experiment datetime ranges. An experiment must keep track of the dates and time slots for each day that it is offered. We decided that having two intermediate classes, ExperimentDate and ExperimentDateTimeRange, would reduce coupling and ensure easier maintainability of the system. The ExperimentDate class keeps track of the slots that the ExperimentDateTimeRange can generate. This enables the user to enter a time range and the system will then calculate the specific time slots. The Experiment class just has to have the ExperimentDates. This makes the coupling of time slots to experiments cleaner. An alternative would be for the experiment to have a massive list of all the dates and slots that it is offered. This would make it difficult to add or remove slots later and not know which slots are current filled participants.

\subsection{Polymorphism}
Currently, the Participant Scheduling System requires both researchers and participants. In order to accomplish this, a User class was introduced to provide a standard base class and then the Researcher class was derived from this. This provides our solution with the polymorphism GRASP principle. The other option was to create two separate classes for researcher and user, but then there would be duplicated code. Furthermore, if there needs to be another type of user then it will be simpler to just extend the current User class.

\subsection{Protected Variation}
In our system, protected variation builds off our decision for polymorphism. The User class enables the protected variation GRASP principle since it protects us from changes in the type of users who need to use the system. If the client comes back with a request for another type of user besides participant and researcher, the system is setup to handle this by just extending the User class. This provides the most elegant solution to the problem since the other option would have been to create the different user classes separately and would make it difficult to extend later.